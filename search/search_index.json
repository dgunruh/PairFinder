{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BestPairsFinder Given an even number of particles, this module is able to find groups of the closest possible pairs. The goal of this implementation is to solve for the global minimum of the summed distance in between particle pairs for 100 particles in fewer than 30 seconds. Example This is an example for 6 particles in 2 dimensions using the greedy graph approach (recommended). from pairfinder.src.best_pairs_finder import BestPairsFinder finder = BestPairsFinder() particle_positions = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] pairing = finder.find_best_pairs(particle_positions, method='greedy') Methods There are four different method options for finding the optimal pairing: enumerate (brute force method) greedy (naive graph-based approach) COM (informed graph-based approach) simulated_annealing (Monte Carlo stochastic process) The enumerate option scales poorly and is not recommended for 16+ particles.","title":"Home"},{"location":"#bestpairsfinder","text":"Given an even number of particles, this module is able to find groups of the closest possible pairs. The goal of this implementation is to solve for the global minimum of the summed distance in between particle pairs for 100 particles in fewer than 30 seconds.","title":"BestPairsFinder"},{"location":"#example","text":"This is an example for 6 particles in 2 dimensions using the greedy graph approach (recommended). from pairfinder.src.best_pairs_finder import BestPairsFinder finder = BestPairsFinder() particle_positions = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] pairing = finder.find_best_pairs(particle_positions, method='greedy')","title":"Example"},{"location":"#methods","text":"There are four different method options for finding the optimal pairing: enumerate (brute force method) greedy (naive graph-based approach) COM (informed graph-based approach) simulated_annealing (Monte Carlo stochastic process) The enumerate option scales poorly and is not recommended for 16+ particles.","title":"Methods"},{"location":"installation/","text":"How to install the module Install PairFinder by first cloning the repository, entering your username and password when prompted: git clone https://github.com/dgunruh/PairFinder You can then pip install this module by navigating in the terminal to the directory with the README and entering pip install . or equivalently pip install /path/to/this/directory/ .","title":"Installation"},{"location":"installation/#how-to-install-the-module","text":"Install PairFinder by first cloning the repository, entering your username and password when prompted: git clone https://github.com/dgunruh/PairFinder You can then pip install this module by navigating in the terminal to the directory with the README and entering pip install . or equivalently pip install /path/to/this/directory/ .","title":"How to install the module"},{"location":"pairfinder-reference/","text":"PairFinder module Pair particles together such that the total distance is minimized. __init__ ( self ) special Init function. Source code in pairfinder/src/best_pairs_finder.py def __init__ ( self ): \"\"\"Init function.\"\"\" find_best_pairs ( self , particle_positions , method = 'greedy' ) Find pairs of closest particles given their coordinates. Multiple methods are implemented, and each method functions slightly differently. The methods are: Enumerate method: 1. Check that the input is iterable 2. Enumerate every possible particle pairing 3. Create combinations of these pairs to include every particle 4. Return the combination that has the smallest summed distance Graph method (both greedy and COM): 1. Check that the input is iterable 2. Save particle index to coordinate/ position in a dictionary 3. Create distance matrix between all points (N x N) 4. Pair particles using greedy or center of mass approach 5. Convert paired particles from indices to coordinates and return Simulated annealing method: 1. Check that the input particles object is iterable 2. Create initial pairs of particles using various methods: 2a. Linear pairing (pair in order of indices) 2b. Random pairing (pair randomly until no particles remain) 2c. Greedy pairing (pair particles in smallest distance order) 3. Run simulated annealing with set beta parameters (max, min and step size), and number of annealing steps per beta step. Parameters particle_positions : list positions of N particles in D dimensions method : string , optional The method by which the best pairs are found. Options are \"enumerate\", \"greedy\", \"COM\" and \"simulated-annealing\". By default, the method is `\"greedy\"`. Returns paired_particles : list Combination of pairs which minimizes the overall distances between particles. Examples Find the optimal pairing of 6 particles in 2-dimensions using the \"greedy\" graph approach: >>> finder = BestPairsFinder() >>> particle_positions = create_even_number_of_particles(6, 2, seed=42) >>> pairing, distance = finder.find_best_pairs(particle_positions, method='greedy') Source code in pairfinder/src/best_pairs_finder.py def find_best_pairs ( self , particle_positions , method = 'greedy' ): \"\"\" Find pairs of closest particles given their coordinates. Multiple methods are implemented, and each method functions slightly differently. The methods are: Enumerate method: 1. Check that the input is iterable 2. Enumerate every possible particle pairing 3. Create combinations of these pairs to include every particle 4. Return the combination that has the smallest summed distance Graph method (both greedy and COM): 1. Check that the input is iterable 2. Save particle index to coordinate/ position in a dictionary 3. Create distance matrix between all points (N x N) 4. Pair particles using greedy or center of mass approach 5. Convert paired particles from indices to coordinates and return Simulated annealing method: 1. Check that the input particles object is iterable 2. Create initial pairs of particles using various methods: 2a. Linear pairing (pair in order of indices) 2b. Random pairing (pair randomly until no particles remain) 2c. Greedy pairing (pair particles in smallest distance order) 3. Run simulated annealing with set beta parameters (max, min and step size), and number of annealing steps per beta step. Parameters ---------- particle_positions : `list` positions of N particles in D dimensions method : `string`, *optional* The method by which the best pairs are found. Options are \"enumerate\", \"greedy\", \"COM\" and \"simulated-annealing\". By default, the method is `\"greedy\"`. Returns ------- paired_particles : `list` Combination of pairs which minimizes the overall distances between particles. Examples -------- Find the optimal pairing of 6 particles in 2-dimensions using the `\"greedy\"` graph approach: >>> finder = BestPairsFinder() >>> particle_positions = create_even_number_of_particles(6, 2, seed=42) >>> pairing, distance = finder.find_best_pairs(particle_positions,\\ method='greedy') \"\"\" if method == 'enumerate' : # Step 1: Check that particle_positions is iterable self . _check_iterable ( particle_positions ) # Step 2: Enumerate all pairs of particles pairs = self . _create_pairs ( particle_positions ) # Step 3: Create combinations of these pairs combos = self . _create_combinations ( pairs , len ( particle_positions ) // 2 , len ( particle_positions ) - 1 ) # Step 4: Return minimum distance combination (and its distance) return self . _choose_best_combination ( combos ) elif method in [ 'greedy' , 'COM' ]: # Step 1: Check that particle_positions is iterable self . _check_iterable ( particle_positions ) # Step 2: Save index to coordinate map self . idx_to_coord_map = { i : coord for i , coord in enumerate ( particle_positions )} # Step 3: Create distance matrix between all points distance_mtx = self . _compute_distance_matrix ( particle_positions ) n = len ( particle_positions ) # set diagonal to inf to prevent selecting self distance_mtx = np . array ( distance_mtx ) distance_mtx [ range ( n ), range ( n )] = np . inf distance_mtx = pd . DataFrame ( distance_mtx ) # Step 4: Pair particles based on specified method self . pairs = [] self . _get_pairs_from_distance_matrix ( distance_mtx , self . pairs , method = method ) # Step 5: Convert particle indices to coordinates using map converted_pairing = [( self . idx_to_coord_map [ pair [ 0 ]], self . idx_to_coord_map [ pair [ 1 ]]) for pair in self . pairs ] return converted_pairing , \\ self . _get_summed_pair_distance ( converted_pairing ) elif method == 'simulated_annealing' : # Step 1: Check that particle_positions is iterable self . _check_iterable ( particle_positions ) # Step 2: Create initial pairing of particles self . pairs = self . _create_single_combination ( particle_positions , \"greedy\" ) # Run simulated annealing with set parameters self . _run_simulated_annealing ( self . pairs , 10000 , 100 , 0.25 , 0.25 ) return self . pairs , \\ self . _get_summed_pair_distance ( self . pairs )","title":"PairFinder"},{"location":"pairfinder-reference/#pairfinder-module","text":"Pair particles together such that the total distance is minimized.","title":"PairFinder module"},{"location":"pairfinder-reference/#pairfinder.src.best_pairs_finder.BestPairsFinder.__init__","text":"Init function. Source code in pairfinder/src/best_pairs_finder.py def __init__ ( self ): \"\"\"Init function.\"\"\"","title":"__init__()"},{"location":"pairfinder-reference/#pairfinder.src.best_pairs_finder.BestPairsFinder.find_best_pairs","text":"Find pairs of closest particles given their coordinates. Multiple methods are implemented, and each method functions slightly differently. The methods are: Enumerate method: 1. Check that the input is iterable 2. Enumerate every possible particle pairing 3. Create combinations of these pairs to include every particle 4. Return the combination that has the smallest summed distance Graph method (both greedy and COM): 1. Check that the input is iterable 2. Save particle index to coordinate/ position in a dictionary 3. Create distance matrix between all points (N x N) 4. Pair particles using greedy or center of mass approach 5. Convert paired particles from indices to coordinates and return Simulated annealing method: 1. Check that the input particles object is iterable 2. Create initial pairs of particles using various methods: 2a. Linear pairing (pair in order of indices) 2b. Random pairing (pair randomly until no particles remain) 2c. Greedy pairing (pair particles in smallest distance order) 3. Run simulated annealing with set beta parameters (max, min and step size), and number of annealing steps per beta step.","title":"find_best_pairs()"},{"location":"pairfinder-reference/#pairfinder.src.best_pairs_finder.BestPairsFinder.find_best_pairs--parameters","text":"particle_positions : list positions of N particles in D dimensions method : string , optional The method by which the best pairs are found. Options are \"enumerate\", \"greedy\", \"COM\" and \"simulated-annealing\". By default, the method is `\"greedy\"`.","title":"Parameters"},{"location":"pairfinder-reference/#pairfinder.src.best_pairs_finder.BestPairsFinder.find_best_pairs--returns","text":"paired_particles : list Combination of pairs which minimizes the overall distances between particles.","title":"Returns"},{"location":"pairfinder-reference/#pairfinder.src.best_pairs_finder.BestPairsFinder.find_best_pairs--examples","text":"Find the optimal pairing of 6 particles in 2-dimensions using the \"greedy\" graph approach: >>> finder = BestPairsFinder() >>> particle_positions = create_even_number_of_particles(6, 2, seed=42) >>> pairing, distance = finder.find_best_pairs(particle_positions, method='greedy') Source code in pairfinder/src/best_pairs_finder.py def find_best_pairs ( self , particle_positions , method = 'greedy' ): \"\"\" Find pairs of closest particles given their coordinates. Multiple methods are implemented, and each method functions slightly differently. The methods are: Enumerate method: 1. Check that the input is iterable 2. Enumerate every possible particle pairing 3. Create combinations of these pairs to include every particle 4. Return the combination that has the smallest summed distance Graph method (both greedy and COM): 1. Check that the input is iterable 2. Save particle index to coordinate/ position in a dictionary 3. Create distance matrix between all points (N x N) 4. Pair particles using greedy or center of mass approach 5. Convert paired particles from indices to coordinates and return Simulated annealing method: 1. Check that the input particles object is iterable 2. Create initial pairs of particles using various methods: 2a. Linear pairing (pair in order of indices) 2b. Random pairing (pair randomly until no particles remain) 2c. Greedy pairing (pair particles in smallest distance order) 3. Run simulated annealing with set beta parameters (max, min and step size), and number of annealing steps per beta step. Parameters ---------- particle_positions : `list` positions of N particles in D dimensions method : `string`, *optional* The method by which the best pairs are found. Options are \"enumerate\", \"greedy\", \"COM\" and \"simulated-annealing\". By default, the method is `\"greedy\"`. Returns ------- paired_particles : `list` Combination of pairs which minimizes the overall distances between particles. Examples -------- Find the optimal pairing of 6 particles in 2-dimensions using the `\"greedy\"` graph approach: >>> finder = BestPairsFinder() >>> particle_positions = create_even_number_of_particles(6, 2, seed=42) >>> pairing, distance = finder.find_best_pairs(particle_positions,\\ method='greedy') \"\"\" if method == 'enumerate' : # Step 1: Check that particle_positions is iterable self . _check_iterable ( particle_positions ) # Step 2: Enumerate all pairs of particles pairs = self . _create_pairs ( particle_positions ) # Step 3: Create combinations of these pairs combos = self . _create_combinations ( pairs , len ( particle_positions ) // 2 , len ( particle_positions ) - 1 ) # Step 4: Return minimum distance combination (and its distance) return self . _choose_best_combination ( combos ) elif method in [ 'greedy' , 'COM' ]: # Step 1: Check that particle_positions is iterable self . _check_iterable ( particle_positions ) # Step 2: Save index to coordinate map self . idx_to_coord_map = { i : coord for i , coord in enumerate ( particle_positions )} # Step 3: Create distance matrix between all points distance_mtx = self . _compute_distance_matrix ( particle_positions ) n = len ( particle_positions ) # set diagonal to inf to prevent selecting self distance_mtx = np . array ( distance_mtx ) distance_mtx [ range ( n ), range ( n )] = np . inf distance_mtx = pd . DataFrame ( distance_mtx ) # Step 4: Pair particles based on specified method self . pairs = [] self . _get_pairs_from_distance_matrix ( distance_mtx , self . pairs , method = method ) # Step 5: Convert particle indices to coordinates using map converted_pairing = [( self . idx_to_coord_map [ pair [ 0 ]], self . idx_to_coord_map [ pair [ 1 ]]) for pair in self . pairs ] return converted_pairing , \\ self . _get_summed_pair_distance ( converted_pairing ) elif method == 'simulated_annealing' : # Step 1: Check that particle_positions is iterable self . _check_iterable ( particle_positions ) # Step 2: Create initial pairing of particles self . pairs = self . _create_single_combination ( particle_positions , \"greedy\" ) # Run simulated annealing with set parameters self . _run_simulated_annealing ( self . pairs , 10000 , 100 , 0.25 , 0.25 ) return self . pairs , \\ self . _get_summed_pair_distance ( self . pairs )","title":"Examples"}]}